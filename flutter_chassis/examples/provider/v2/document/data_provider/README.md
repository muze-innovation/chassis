# Get Started

`DataProvider` (V2) works with `Chassis back-end` pre-generated files and `Chassis generator`.

---

## Place your pre-generated files

Before we get started, you have to put your **pre-generated files**, which are generated from `Chassis back-end`, into your module. We sugguest you not to modify these files to avoid missing codes issue when they're re-generated.

Given the pre-generated data resolver files:
- `data_resolver.dart` with an abstract `DataResolver` that extends `DataResolverBase` (Chassis Core) and `DataResolverEntry` (Pre-generated)
- `data_resolver.part.dart` is part of `data_resolver.dart` with an abstract `DataResolverEntry` provides 2 streams of different data: 
  - `getData1` - binded with resolver named "get-data-1".
  - `getData2` - binded with resolver named "get-data-2".


And given the pre-generated IO files:
- `data_1_input.dart` with `Data1Input` that extend `Input` (Chassis Core).
- `data_1_output.dart` with `Data1Output` that extend `Output` (Chassis Core).
- `data_2_input.dart` with `Data2Input` that extend `Input` (Chassis Core).
- `data_2_output.dart` with `Data2Output` that extend `Output` (Chassis Core).<br></br>

## Create your DataResolver

Next, you have to create your data-resolver class to override methods, which are annotated with `@Resolves`, in an abstract `DataResolver`, and then annotate it with `@annotation.DataResolver` (Chassis Annotation).

``` dart
// data_resolver.dart

import 'dart:async';

import 'package:chassis_core/core.dart';
import 'package:chassis_annotation/annotation.dart';
... // other imports

part 'data_resolver.part.dart';

/// Generated by Chassis Back-end
abstract class DataResolver extends DataResolverBase with DataResolverEntry {

  @override
  Stream<Output>? resolveWith(Request request) {
    final resolver = request.resolvedWith;
    switch (resolver) {
      case "get-data-1":
        return getData1(Data1Input.fromRequest(request));
      case "get-data-2":
        return getData2(Data2Input.fromRequest(request));
      default:
        return super.resolveWith(request);
    }
  }
}
```

</br>

So, given that you created a file `example_data_resolver.dart` with a `ExampleDataResolver` that extends an abstract `DataResolver`.

``` dart
// example_data_resolver.dart

import 'package:chassis_annotation/annotation.dart' as annotation;

/// Created by User
@annotation.DataResolver()
class ExampleDataResolver extends DataResolver {}
```

</br>

You will be able to override **one or many** method from `DataResolver`, depends on your consideration. You can check your available override methods (resolver) in `DataResolverEntry`.

``` dart
// data_resolver.part.dart

part of 'data_resolver.dart';

/// List of available resolver
/// Generated by Chassis Back-end
abstract class DataResolverEntry {
  @Resolves(resolvedWith: "get-data-1")
  Stream<Data1Output>? getBanner(Data1Input input) => null;

  @Resolves(resolvedWith: "get-data-2")
  Stream<Data2Output>? getBannerV2(Data2Input input) => null;
}
```

</br>

Suppose that you want to override both `getData1` and `getData2`.

``` dart
@annotation.DataResolver()
class ExampleDataResolver extends DataResolver {

  @override
  Stream<Data1Output>? getData1(Data1Input input) {
    // TODO: implement getData1
    return super.getData1(input);
  }

  @override
  Stream<Data2Output>? getData2(Data12nput input) {
    // TODO: implement getData2
    return super.getData2(input);
  }
}
```

</br>

### Link with your codes

Suppose you have your own *use-cases*, *repositories*, or *any kind of data-sources*.

You can link them with your created data-resolver by injecting them via its constructor, as dependencies, and **modifing your overridden methods' returns** (at `// TODO: ...` and `return ...`) and **map data** from your data-sources to each `Output` type.</br></br>

Let's say, you had a `ExampleRepository` as your respoitory, and it has methods inclduing:

- `getData` related to `DataResolver`'s `getData1`.
- `getDataV2` related to `DataResolver`'s `getData2`.

And then inject it into your `ExampleDataResolver` as dependency.

``` dart
@annotation.DataResolver()
class ExampleDataResolver extends DataResolver {

  final ExampleRepository _repository;

  ExampleDataResolver({required ExampleRepository repository})
      : _repository = repository;

  @override
  Stream<Data1Output>? getData1(Data1Input input) {
    return _repository.getData(input.slug).asStream().map((event) =>
        Data1Output(
          // Implement your data mapping here
        ));
  }

  @override
  Stream<Data2Output>? getData2(Data12nput input) {
    return _repository.getDataV2(input.slug).asStream().map((event) =>
        Data2Output(
          // Implement your data mapping here
        ));
  }
}
```

</br>

### Create route table

Actually, we don't create it manually, we will generate it by adding 2 following lines to your your `ExampleDataResolver`.

``` dart
// Add [1] below the imports
part 'example_data_resolver.chassis.dart'; // required

@annotation.DataResolver()
class ExampleDataResolver extends DataResolver {

  ...

  // Add [2] to somewhere of your data-resolver class
  // Connect the generated [$_getRouteTableForExampleDataResolver]
  @override
  Map<String, DataResolver> get routeTable =>
      _getRouteTableForExampleDataResolver(this);
}
```

</br>

A `_getRouteTableForExampleDataResolver` method will yet be created in a generated file `example_data_resolver.chassis.dart`. But for now, the file will not occur unless everthing has done.

</br>

## Create your DataProvider

Given that you created a file `data_provider.dart` with a `DataProvider` class that extend `_DataProvider` and annotated with `@annotation.DataProvider`.

``` dart
// data_provider.dart
import 'dart:async'; // required

import 'package:chassis_annotation/annotation.dart' as annotation; // required

part 'data_provider.chassis.dart'; 

/// A concrete of data provider.
/// Created by User (Generated by build_runner)
@annotation.DataProvider(resolvers: [])
class DataProvider extends _DataProvider {}
```

We use ``@annotation.DataProvider`` to let the generator know that this class is data-provider, the generator will generate this `_DataProvider` for you.

</br>

### Register your DataResolver

Now you have to register `ExampleDataResolver` to `DataProvider` by adding to `@annotation.DataProvider` as a parameter `resolvers`.

``` dart
@annotation.DataProvider(resolvers: [ExampleDataResolver])
class DataProvider extends _DataProvider {}
```

You can see that the annotation parameter is `List<Type>`, it mean you can add one or many `DataResolver` there. 

For route table, when generator has done a process, your data-provider will collect route tables from your registed data-resolvers, and then transfrom them into its own route table.

</br>

## Generate your codes

When all the aboves has done, use [builder_runner](https://pub.dev/packages/build_runner/install) to generate you missing files by running this command:

``` bat
  flutter pub add build_runner {YOUR_PACKAGE}
```

Next, you have to fix your `DataProvider` by adding its missing constructor:

``` dart
@annotation.DataProvider(resolvers: [ExampleDataResolver])
class DataProvider extends _DataProvider {
   DataProvider({required super.mExampleDataResolver});
}
```
